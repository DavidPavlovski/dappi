using Microsoft.AspNetCore.Mvc;
using System.Diagnostics;
using System.Reflection;
using Microsoft.Extensions.Hosting;

namespace CCApi.Extensions.DependencyInjection.Controllers;
[ApiExplorerSettings(GroupName = "Toolkit")]
[ApiController]
[Route("api/create-migrations-update-db")]
public class MigrationController : ControllerBase
{
    private readonly IHostApplicationLifetime _appLifetime;
    private readonly string _projectDirectory;

    public MigrationController(
        IHostApplicationLifetime appLifetime)
    {
        _appLifetime = appLifetime;
        _projectDirectory = Path.GetDirectoryName(Assembly.GetEntryAssembly() is not null ? Assembly.GetEntryAssembly().Location : Directory.GetCurrentDirectory());
    }

    [HttpPost]
    public IActionResult ApplyMigrationsAndRestart()
    {
        try
        {
            if (OperatingSystem.IsWindows())
            {
                RunDbMigrationScenarioForWindows();
            }
            else
            {
                RunDbMigrationScenario();
            }

            return Ok("Migrations applied. Application restarting...");
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Error: {ex.Message}");
        }
    }

    private void RunDbMigrationScenario()
    {
        GenerateMigrationsIfNeeded();
        var directory = Path.GetDirectoryName(Assembly.GetEntryAssembly()?.Location);
        Console.WriteLine(directory);
        ApplyMigrationsAfterRestart(directory);
        RestartApplication();
        _appLifetime.StopApplication();
    }

    private void RunDbMigrationScenarioForWindows()
    {
        var currentDir = Directory.GetCurrentDirectory();
        var csproj = Directory.GetFiles(currentDir, "*.csproj", SearchOption.TopDirectoryOnly).FirstOrDefault();
        var csprojFileName = Path.GetFileName(csproj);
        var dllPath = Directory
            .GetFiles(currentDir, "*.dll", SearchOption.AllDirectories)
            .FirstOrDefault(f => f.Contains("bin") && Path.GetFileNameWithoutExtension(f) == Path.GetFileNameWithoutExtension(csprojFileName));

        var appDll = Path.GetFileName(dllPath);
        var scriptPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!, "DappiMigrationRunner.ps1");
        var procId = Environment.ProcessId;
    
        var args = $"-ExecutionPolicy Bypass -File \"{scriptPath}\" -ProjectPath \"{_projectDirectory}\" -Csproj \"{csproj}\" -AppDll \"{appDll}\" -ProcessId \"{procId}\" ";
        var psi = new ProcessStartInfo
        {
            FileName = "powershell.exe",
            Arguments = args,
            UseShellExecute = true,
            CreateNoWindow = true,
        };

        Process.Start(psi);
    }

    private void GenerateMigrationsIfNeeded()
    {

        var migrationDirectory = Path.Combine(_projectDirectory, "Migrations");
        if (!Directory.Exists(migrationDirectory))
        {
            Directory.CreateDirectory(migrationDirectory);
        }
        string formattedDate = DateTime.Now.ToString("yyyyMMddHHmmss");

        ProcessStartInfo startInfo = new ProcessStartInfo
        {
            WorkingDirectory = Directory.GetCurrentDirectory(),
            FileName = "dotnet.exe",
            Arguments = $"ef migrations add AutoGeneratedMigration_{formattedDate}",
            UseShellExecute = false,
            CreateNoWindow = true
        };
        Process.Start(startInfo)?.WaitForExit();
    }

    private void RestartApplication()
    {
        try
        {
            var exePath = Assembly.GetEntryAssembly()?.Location;
            if (exePath != null)
            {
                var directory = Path.GetDirectoryName(exePath);
                var processId = Process.GetCurrentProcess().Id;
                string scriptPath;
                string scriptContent;
                if (OperatingSystem.IsWindows())
                {
                    scriptPath = Path.Combine(directory, "restart.bat");
                    scriptContent = $@"
@echo off
set pid={processId}
set app_path=""{exePath}""

:waitloop
tasklist /FI ""PID eq %pid%"" | find /I ""%pid%"" >nul
if not errorlevel 1 (
    timeout /t 1 >nul
    goto waitloop
)

start """" dotnet ""%app_path%""
exit
";
                }
                else
                {
                    scriptPath = Path.Combine(directory, "restart.sh");
                    scriptContent = $@"
#!/bin/bash
pid={processId}
app_path=""{exePath}""

# Wait until the old process exits
while kill -0 ""$pid"" 2>/dev/null; do sleep 1; done

# Start the new instance
dotnet ""$app_path"" &
";
                    System.IO.File.WriteAllText(scriptPath, scriptContent);
                    Process.Start("chmod", new[] { "+x", scriptPath })?.WaitForExit();
                }
                System.IO.File.WriteAllText(scriptPath, scriptContent);
                var startInfo = new ProcessStartInfo
                {
                    FileName = OperatingSystem.IsWindows() ? "cmd.exe" : "/bin/bash",
                    Arguments = OperatingSystem.IsWindows() ? $"/c \"{scriptPath}\"" : $"-c \"{scriptPath}\"",
                    UseShellExecute = false,
                    CreateNoWindow = true
                };
                Process.Start(startInfo);
                _appLifetime.StopApplication();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to restart application: {ex.Message}");
        }
    }

    private void ApplyMigrationsAfterRestart(string directory)
    {
        try
        {
            ProcessStartInfo startInfo = new ProcessStartInfo
            {
                FileName = "dotnet",
                Arguments = $"ef database update --project {_projectDirectory}/../../../CCApi.WebApiExample.csproj",
                UseShellExecute = false,
                CreateNoWindow = true
            };
            Process.Start(startInfo)?.WaitForExit();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to apply migrations after restart: {ex.Message}");
        }
    }

    private void DirectoryCopy(string sourceDirName, string destDirName, bool copySubDirs)
    {
        DirectoryInfo dir = new DirectoryInfo(sourceDirName);
        DirectoryInfo[] dirs = dir.GetDirectories();
        Directory.CreateDirectory(destDirName);

        foreach (FileInfo file in dir.GetFiles())
        {
            string temppath = Path.Combine(destDirName, file.Name);
            file.CopyTo(temppath, false);
        }

        if (copySubDirs)
        {
            foreach (DirectoryInfo subdir in dirs)
            {
                string temppath = Path.Combine(destDirName, subdir.Name);
                DirectoryCopy(subdir.FullName, temppath, copySubDirs);
            }
        }
    }
}
